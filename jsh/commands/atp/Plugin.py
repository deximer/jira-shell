''' atp: Available To Promise

   ATP seeks to answer the question "given what we know about the specific characterisitcs of a ticket, what can we say about it's likelyhood of completion"? This is an inversion of the question "given what we know generally about all other tickets, what can we say about the likelyhood of completion for this ticket specifically"? ATP will reclassify the specific issue in order to maintain a future prediction. It will not simply return a negative number when cycle times are exceeded. It asks "given that the ticket is outside the predictions, what is it now most like and what does that mean concerning predictability"?
   ATP looks at the characteristics of the ticket and recalculates based on the tickets current profile and the historical conditions that gives it meaning:

   * Current state of the ticket
   * Aggregate cycle time (all attempts)
   * Number of restarts
   * Accrued cycle time in latest attempt
   * Time spread between last and latest attempt
   * Cycle times of developer assigned
   * Delta between last attempt dev CT and current attempt dev CT
   * Bugs generated by ticket
   * Blocking ticket links (analyze these by metrics of responsible teams)

Options:

   * Show gaps in flow do to priorities of dependencies

   The results of ATP can not be used to drive conditions, only monitor them.
'''

import getopt
import argparse
import sets
import datetime
from dateutil.rrule import DAILY, SA, SU, rrule
from ..base import BaseCommand
try:
    from model import humanize
except:
    from ...model import humanize

class Command(BaseCommand):
    help = 'Provide estimate delivery dates.'
    usage = 'atp [issue_id] [-l label] [-c component] [-v version]'
    options_help = ''''''
    examples = '''    atp POOL-1
    atp -l non247
    atp -c ui
    '''

    def run(self, jira, args):
        parser = argparse.ArgumentParser()
        parser.add_argument('-c', nargs='*', required=False)
        parser.add_argument('-l', nargs='*', required=False)
        parser.add_argument('-v', nargs='*', required=False)
        parser.add_argument('select', nargs='?')
        try:
            args = parser.parse_args(args)
        except:
            return
        container = jira.cache.get_by_path(jira.cache.cwd)
        kanban = container.kanban()
        stories = []
        if args.l:
            stories = container.stories_for_labels(args.l)
        elif args.c:
            stories = container.stories_for_components(args.c)
        elif args.v:
            stories = container.stories_for_versions(args.v)
        else:
            stories.append(container.get(args.select))
            if not args.select or not [s for s in stories if s]:
                print 'Nothing to do (hint: help atp)'
                return
        report = []
        kanban = container.kanban()
        print 'ATP:'.ljust(10), 'Rank:', 'Status:', 'ID:'.ljust(8), 'Delta to:'
        for story in stories:
            if story.status in [5, 6]:
                continue
            atp = kanban.atp(story)
            if not atp:
                continue
            days = int(round(atp, 0))
            now = datetime.datetime.now()
            atp = now + datetime.timedelta(days)
            report.append('%s %s %s %s %s days' % (str(atp)[:10],
                str(kanban.rank_depth(story)).ljust(5),
                humanize(story.status).ljust(7), story.key.ljust(8), str(days)))

        report.sort()
        for item in report:
            print item

